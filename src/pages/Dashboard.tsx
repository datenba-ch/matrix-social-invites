import React, { useState, useEffect, useRef } from 'react';
import { useAuth } from '@/contexts/AuthContext';
import { useInviteCode } from '@/hooks/useInviteCode';
import PixelCompanion from '@/components/PixelCompanion';
import PixelButton from '@/components/PixelButton';
import BulletinBoard from '@/components/BulletinBoard';
import TearOffCode from '@/components/TearOffCode';
import CountdownWheel from '@/components/CountdownWheel';
import QRCodeOverlay from '@/components/QRCodeOverlay';
import ForestBackground from '@/components/ForestBackground';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@/components/ui/alert-dialog';

type CompanionMood = 'idle' | 'happy' | 'excited' | 'sleeping' | 'waving' | 'thinking' | 'celebrating' | 'curious' | 'surprised';

const MOOD_CYCLE: CompanionMood[] = ['happy', 'excited', 'waving', 'celebrating', 'curious', 'surprised', 'thinking', 'sleeping'];

const Dashboard: React.FC = () => {
  const { user, logout } = useAuth();
  const {
    inviteCode,
    isGenerating,
    generateInviteCode,
    regenerateCode,
    hasActiveCode,
    getTimeRemaining,
    getProgress,
    initialInviteLoaded,
  } = useInviteCode();

  const [autoGeneratedFor, setAutoGeneratedFor] = useState<string | null>(null);

  const [showQR, setShowQR] = useState(false);
  const [showRegenerateDialog, setShowRegenerateDialog] = useState(false);
  const [companionMood, setCompanionMood] = useState<CompanionMood>('idle');
  const [companionMessage, setCompanionMessage] = useState('');
  const [timeRemaining, setTimeRemaining] = useState(getTimeRemaining());
  const [justGenerated, setJustGenerated] = useState(false);
  const [moodCycleIndex, setMoodCycleIndex] = useState(-1);
  const [isManualMood, setIsManualMood] = useState(false);
  const cardRef = useRef<HTMLDivElement>(null);
  const [backgroundAttraction, setBackgroundAttraction] = useState<{ x: number; y: number } | null>(null);
  const [backgroundAttractionMoving, setBackgroundAttractionMoving] = useState(false);
  const pointerIdleTimer = useRef<number>();

  // Update time remaining every minute
  useEffect(() => {
    setTimeRemaining(getTimeRemaining());

    const interval = setInterval(() => {
      setTimeRemaining(getTimeRemaining());
    }, 60000);

    return () => clearInterval(interval);
  }, [getTimeRemaining]);

  useEffect(() => {
    const handlePointerMove = (event: PointerEvent) => {
      const rect = cardRef.current?.getBoundingClientRect();
      const isOverCard = rect
        ? event.clientX >= rect.left &&
          event.clientX <= rect.right &&
          event.clientY >= rect.top &&
          event.clientY <= rect.bottom
        : false;

      if (isOverCard) {
        setBackgroundAttraction(null);
        setBackgroundAttractionMoving(false);
        if (pointerIdleTimer.current) {
          window.clearTimeout(pointerIdleTimer.current);
          pointerIdleTimer.current = undefined;
        }
        return;
      }

      const normalized = {
        x: Math.min(99, Math.max(1, (event.clientX / window.innerWidth) * 100)),
        y: Math.min(92, Math.max(5, (event.clientY / window.innerHeight) * 100)),
      };
      setBackgroundAttraction(normalized);
      setBackgroundAttractionMoving(true);
      if (pointerIdleTimer.current) {
        window.clearTimeout(pointerIdleTimer.current);
      }
      pointerIdleTimer.current = window.setTimeout(() => {
        setBackgroundAttractionMoving(false);
        pointerIdleTimer.current = undefined;
      }, 250);
    };

    const handlePointerLeave = () => {
      setBackgroundAttraction(null);
      setBackgroundAttractionMoving(false);
      if (pointerIdleTimer.current) {
        window.clearTimeout(pointerIdleTimer.current);
        pointerIdleTimer.current = undefined;
      }
    };

    window.addEventListener('pointermove', handlePointerMove);
    window.addEventListener('pointerleave', handlePointerLeave);
    window.addEventListener('pointerup', handlePointerLeave);
    window.addEventListener('pointercancel', handlePointerLeave);

    return () => {
      window.removeEventListener('pointermove', handlePointerMove);
      window.removeEventListener('pointerleave', handlePointerLeave);
      window.removeEventListener('pointerup', handlePointerLeave);
      window.removeEventListener('pointercancel', handlePointerLeave);
      if (pointerIdleTimer.current) {
        window.clearTimeout(pointerIdleTimer.current);
        pointerIdleTimer.current = undefined;
      }
    };
  }, []);

  useEffect(() => {
    if (!user) {
      setAutoGeneratedFor(null);
    }
  }, [user]);

  useEffect(() => {
    if (!user || !initialInviteLoaded) return;
    if (inviteCode || isGenerating) {
      if (inviteCode) {
        setAutoGeneratedFor(user.id);
      }
      return;
    }

    if (autoGeneratedFor === user.id) {
      return;
    }

    setAutoGeneratedFor(user.id);
    void generateInviteCode().catch(() => {
      setAutoGeneratedFor(null);
    });
  }, [user, inviteCode, isGenerating, autoGeneratedFor, generateInviteCode, initialInviteLoaded]);

  // Update companion based on state (only if not in manual mood mode)
  useEffect(() => {
    if (isManualMood) return;
    
    if (isGenerating) {
      setCompanionMood('excited');
      setCompanionMessage('Erstelle deinen Code...');
    } else if (justGenerated) {
      setCompanionMood('celebrating');
      setCompanionMessage('Dein neuer Code ist bereit!');
      const timer = setTimeout(() => setJustGenerated(false), 3000);
      return () => clearTimeout(timer);
    } else if (hasActiveCode) {
      const remaining = getTimeRemaining();
      if (remaining && remaining.days <= 1) {
        setCompanionMood('curious');
        setCompanionMessage('Dein Code läuft bald ab!');
      } else if (remaining && remaining.days <= 3) {
        setCompanionMood('thinking');
        setCompanionMessage('Noch ein paar Tage für diesen Code.');
      } else {
        setCompanionMood('happy');
        setCompanionMessage('Dein Code ist bereit zum Teilen!');
      }
    } else {
      setCompanionMood('idle');
      setCompanionMessage('Erstelle einen neuen Einladungscode!');
    }
  }, [isGenerating, hasActiveCode, getTimeRemaining, justGenerated, isManualMood]);

  // Handle companion touch - cycle through moods (keep message visible)
  const handleCompanionTouch = () => {
    const nextIndex = (moodCycleIndex + 1) % MOOD_CYCLE.length;
    setMoodCycleIndex(nextIndex);
    setIsManualMood(true);
    setCompanionMood(MOOD_CYCLE[nextIndex]);
    
    // Return to automatic mood after 3 seconds
    setTimeout(() => {
      setIsManualMood(false);
    }, 3000);
  };

  const handleGenerateCode = async () => {
    await generateInviteCode();
    setJustGenerated(true);
  };

  const handleRegenerateCode = async () => {
    setShowRegenerateDialog(false);
    await regenerateCode();
    setJustGenerated(true);
  };

  const handleSwipeRegenerate = () => {
    setShowRegenerateDialog(true);
  };

  const handleShare = async () => {
    if (!inviteCode) return;
    
    const shareData = {
      title: 'Datenbach Einladung',
      text: `Hier ist mein Einladungscode: ${inviteCode.code}`,
    };

    if (navigator.share) {
      try {
        await navigator.share(shareData);
        setCompanionMood('celebrating');
        setCompanionMessage('Code wurde geteilt!');
      } catch (err) {
        // User cancelled or share failed
        if ((err as Error).name !== 'AbortError') {
          // Fallback to clipboard
          await navigator.clipboard.writeText(inviteCode.code);
          setCompanionMood('happy');
          setCompanionMessage('Code kopiert!');
        }
      }
    } else {
      // Fallback to clipboard
      await navigator.clipboard.writeText(inviteCode.code);
      setCompanionMood('happy');
      setCompanionMessage('Code kopiert!');
    }
  };

  const handleShowQR = () => {
    setCompanionMood('waving');
    setCompanionMessage('Zeig das deinem Freund!');
    setShowQR(true);
  };

  const handleCloseQR = () => {
    setShowQR(false);
    setCompanionMood('happy');
    setCompanionMessage('Dein Code ist bereit zum Teilen!');
  };

  const progress = getProgress();

  return (
    <div className="min-h-screen bg-background flex flex-col p-4 relative overflow-hidden">
      {/* Animated forest background */}
      <ForestBackground
        showFireflies={true}
        interactionPoint={backgroundAttraction}
        interactionActive={backgroundAttractionMoving}
      />

      {/* Header */}
      <header className="relative z-10 flex items-center justify-between mb-6">
        <div>
          <h1 className="font-pixel text-sm text-primary">DATENBACH</h1>
          <p className="font-pixel text-[8px] text-muted-foreground mt-1">
            {user?.displayName}
          </p>
        </div>
        <PixelButton variant="secondary" size="sm" onClick={logout}>
          ABMELDEN
        </PixelButton>
      </header>

      {/* Main content - restructured layout */}
      <main className="relative z-10 flex-1 flex flex-col">
        {/* Companion in top third - touchable */}
        <div className="flex-none pt-2 pb-4 flex flex-col items-center cursor-pointer" onClick={handleCompanionTouch}>
          <PixelCompanion mood={companionMood} message={companionMessage} size="xl" />
        </div>

        {/* Bulletin board fills remaining space */}
        <div ref={cardRef} className="w-full">
          <BulletinBoard className="flex-1 max-w-sm">
          <div className="flex flex-col flex-1">
            {/* Top section - title and countdown */}
            <div className="flex flex-col flex-1 items-center justify-center text-center gap-6">
              <h2 className="font-pixel text-[16px] leading-none text-foreground">
                EINLADUNGSCODE
              </h2>

              {hasActiveCode && inviteCode && (
                <div className="flex justify-center scale-[1.5]">
                  <CountdownWheel
                    progress={progress}
                    expiresAt={inviteCode.expiresAt}
                  />
                </div>
              )}
            </div>

            {/* Bottom section - code and button pinned to bottom */}
            <div className="mt-auto text-center">
              {hasActiveCode && inviteCode ? (
                <>
                  {/* Tear-off code display with swipe support */}
                  <TearOffCode
                    code={inviteCode.code}
                    onClick={handleShowQR}
                    onSwipeLeft={handleSwipeRegenerate}
                  />

                  {/* Buttons row */}
                  <div className="mt-6 flex justify-center gap-2">
                    <PixelButton
                      variant="secondary"
                      size="sm"
                      onClick={() => setShowRegenerateDialog(true)}
                      disabled={isGenerating}
                    >
                      NEUER CODE
                    </PixelButton>
                    <PixelButton
                      variant="primary"
                      size="sm"
                      onClick={handleShare}
                    >
                      TEILEN
                    </PixelButton>
                  </div>
                </>
              ) : (
                <>
                  {/* No code state */}
                  <p className="font-pixel text-[8px] text-muted-foreground mb-6">
                    Kein aktiver Code
                  </p>

                  {/* Generate button */}
                  <PixelButton
                    variant="primary"
                    size="lg"
                    onClick={handleGenerateCode}
                    disabled={isGenerating}
                    className="animate-pulse-glow"
                  >
                    {isGenerating ? 'ERSTELLE...' : 'CODE ERSTELLEN'}
                  </PixelButton>
                </>
              )}
            </div>
          </div>
          </BulletinBoard>
        </div>
      </main>

      {/* QR Code overlay */}
      {inviteCode && (
        <QRCodeOverlay
          code={inviteCode.code}
          isOpen={showQR}
          onClose={handleCloseQR}
        />
      )}

      {/* Regenerate confirmation dialog - fixed for small viewports */}
      <AlertDialog open={showRegenerateDialog} onOpenChange={setShowRegenerateDialog}>
        <AlertDialogContent className="bg-card border-4 border-border fixed left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 w-[calc(100%-2rem)] max-w-[280px] sm:max-w-lg p-4 sm:p-6">
          <AlertDialogHeader className="flex flex-col items-center space-y-3 sm:space-y-4">
            <div className="flex justify-center">
              <PixelCompanion mood="surprised" size="sm" className="hidden sm:flex" message="Bist du sicher?" />
              <PixelCompanion mood="surprised" size="sm" className="flex sm:hidden" />
            </div>
            <AlertDialogTitle className="font-pixel text-[10px] text-center">
              CODE NEU ERSTELLEN?
            </AlertDialogTitle>
            <AlertDialogDescription className="font-pixel text-[8px] text-center text-muted-foreground leading-relaxed">
              Dies ersetzt deinen aktuellen Code. Der alte Code funktioniert dann nicht mehr.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter className="flex flex-col items-stretch gap-2 mt-3 sm:flex-row sm:items-center sm:justify-center sm:gap-3 sm:mt-4">
            <AlertDialogAction asChild>
              <PixelButton variant="primary" size="sm" onClick={handleRegenerateCode} className="w-full sm:w-auto justify-center">
                NEU ERSTELLEN
              </PixelButton>
            </AlertDialogAction>
            <AlertDialogCancel asChild>
              <PixelButton variant="ghost" size="sm" className="w-full sm:w-auto justify-center">
                ABBRECHEN
              </PixelButton>
            </AlertDialogCancel>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
};

export default Dashboard;
